<!DOCTYPE html><html lang="zh-cn,en,default"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 使用wxWidgets时发现的一些bug及解决方案 · HanDong's Blog</title><meta name="description" content="使用wxWidgets时发现的一些bug及解决方案 - HanDong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/html5-audio-player/" target="_self" class="nav-list-link">MUSIC</a></li><li class="nav-list-item"><a href="https://twitter.com/likev" target="_blank" class="nav-list-link">TWITTER</a></li><li class="nav-list-item"><a href="https://github.com/likev" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">使用wxWidgets时发现的一些bug及解决方案</h1><div class="post-time">2010年10月14日</div><div class="post-content"><p>Ubuntu中</p>
<p>wxDC类</p>
<p>bug 1.  使用SetLogicalOrigin时必须确保坐标轴为默认方向（SetAxisOrientation(true,false)）,使用后可更改为需要的方向(SetAxisOrientation(true,true));</p>
<p>解决方案：查看wxGTK源代码文件dc.cpp可看到如下代码：</p>
<pre lang="cpp">
void wxDC::SetLogicalOrigin( wxCoord x, wxCoord y )
{
    m_logicalOriginX = x * m_signX;   // is this still correct ?
    m_logicalOriginY = y * m_signY;
    ComputeScaleAndOrigin();
}
</pre>

<p>作者也察觉到了这里可能有问题，标注了// is this still correct ?</p>
<p>将上面代码修改如下即可：</p>
<pre lang="cpp">
void wxDC::SetLogicalOrigin( wxCoord x, wxCoord y )
{
    m_logicalOriginX = x ;
    m_logicalOriginY = y ;
    ComputeScaleAndOrigin();
}
</pre>
bug 2\. 使用SetUserScale函数设置放大倍数时画笔（wxPen）的宽度随之放大，但在xp系统下画笔宽度不变。也就是说如果设置SetUserScale(1,1000),则画笔宽度可能变为1000像素，导致无法成功绘制图像。

解决方案：从源代码文件dc.cpp中我们可以看到SetUserScale函数的定义：
<pre lang="cpp">
void wxDC::SetUserScale( double x, double y )
{
    // allow negative ? -> no
    m_userScaleX = x;
    m_userScaleY = y;
    ComputeScaleAndOrigin();
}
</pre>

<p>在源代码文件dcclient.cpp中我们可以看到wxWindowDC::ComputeScaleAndOrigin()函数的定义：</p>
<pre lang="cpp">
void wxWindowDC::ComputeScaleAndOrigin()
{
    const wxRealPoint origScale(m_scaleX, m_scaleY);

    wxDC::ComputeScaleAndOrigin();

    // if scale has changed call SetPen to recalulate the line width
    if ( wxRealPoint(m_scaleX, m_scaleY) != origScale && m_pen.Ok() )
    {
        // this is a bit artificial, but we need to force wxDC to think the pen
        // has changed
        wxPen pen = m_pen;
        m_pen = wxNullPen;
        SetPen( pen );
    }
}
</pre>

<p>进一步我们可以找到函数 wxWindowDC::SetPen 的定义</p>
<pre lang="cpp">
void wxWindowDC::SetPen( const wxPen &pen )

{

    wxCHECK_RET( Ok(), wxT(“invalid window dc”) );
    if (m_pen == pen) return;
    m_pen = pen;
    if (!m_pen.Ok()) return;
    if (!m_window) return;

    gint width = m_pen.GetWidth();
    if (width <= 0="" 0)="" {="" cmb:="" if="" width="" is="" non-zero="" scale="" it="" with="" the="" dc="" }="" else="" x="" doesn’t="" allow="" different="" in="" and="" y="" so="" we="" take="" average="" double="" w="0.5" +="" (="" fabs((double)="" xlog2devrel(width))="" ylog2devrel(width))="" )="" 2.0;="" 注意，这个宽度是最终绘制的宽度="" !width="" can’t="" be="" or="" an="" internal="" gtk="" error="" occurs="" inside="" gdk_gc_set_dashes()="" below="" ……="" 中间的代码省略="" gdk_gc_set_line_attributes(="" m_pengc,="" width,="" linestyle,="" capstyle,="" joinstyle="" );="" m_pen.getcolour().calcpixel(="" m_cmap="" gdk_gc_set_foreground(="" m_pen.getcolour().getcolor()="" <="" pre="">

<p>综合以上代码分析我们可以看到：当我们调用函数SetUserScale 放大绘制的图形时，wxGTK同时放大了绘制线条的宽度。</p>
<p>解决办法是删除 width = (int)w;  这行代码。</p>
<p>修改源代码后，重新编译wxGTK即可。</p>
<p>XP中</p>
<p>wxDateTime</p>
<p>bug 1. wxDateTime::Format 函数不支持中文字符的格式化。</p>
<p>解决方案：暂时可以使用wxString::Format函数替代。</p>
</=></pre></div></article></div></section><footer><div class="paginator"><a href="/2010/10/14/e6-ac-a7-e6-b4-b2-e6-a0-bc-e7-82-b9-e9-a2-84-e6-8a-a5-e6-98-be-e7-a4-ba-e8-bd-af-e4-bb-b6/" class="prev">上一篇</a><a href="/2010/09/17/e5-ad-97-e7-ac-a6-e7-bc-96-e7-a0-81-e7-9a-84-e8-bd-ac-e6-8d-a2-ef-bc-88c-e4-b8-ba-e4-be-8b-ef-bc-89/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://blog.tianqitu.net">HanDong</a>, unless otherwise noted.</p></div></footer><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>