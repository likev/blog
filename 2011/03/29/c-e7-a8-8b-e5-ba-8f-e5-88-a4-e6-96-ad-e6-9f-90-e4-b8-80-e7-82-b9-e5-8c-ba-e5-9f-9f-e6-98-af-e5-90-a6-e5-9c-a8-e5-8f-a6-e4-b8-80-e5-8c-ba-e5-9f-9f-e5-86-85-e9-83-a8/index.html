<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> C++程序 判断某一点/区域 是否在另一区域内部 · HanDong's Blog</title><meta name="description" content="C++程序 判断某一点/区域 是否在另一区域内部 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">C++程序 判断某一点/区域 是否在另一区域内部</h1><div class="post-time">Mar 29, 2011</div><div class="post-content"><p>代码中主要包含两个函数</p>
<pre lang="cpp">
//1\. 判断点point是否在区域rgn内部 1--内部 -1--边界 0--外部
template <typename t="">
int isPointInRgn(const mVector<t> &point, 
                 const std::vector<mvector<t> > &rgn);

//2\. 判断区域B是否在区域A内部
template <typename t="">
bool isRgnInRgn(const std::vector<mvector<t> > &rgnB, 
                const std::vector<mvector<t> > &rgnA);
</mvector<t></mvector<t></typename></mvector<t></t></typename></pre>

<h3 id="使用时包含下面的头文件，然后直接调用函数即可"><a href="#使用时包含下面的头文件，然后直接调用函数即可" class="headerlink" title="使用时包含下面的头文件，然后直接调用函数即可"></a>使用时包含下面的头文件，然后直接调用函数即可</h3><pre lang="cpp">

/*
    利用射线法判断某一点/一个区域 是否属于 另一区域
    2011 3 29 http://blog.lyqx.de/?p=592
*/

#ifndef IS_POINT_IN_RGN
#define IS_POINT_IN_RGN

#include <cmath>
#include <vector>

template <typename t="">
struct mVector //代表一个向量或一个坐标点
{
public:
    T x,y;

    mVector()
        : x(0),y(0)
    {}

    mVector(T a,T b)
    {
        set(a,b);
    }

    void set(T a,T b)
    {
        x=a;
        y=b;
    }

    //向量相加
    mVector<t> add(const mVector<t> &right)const
    {
        return mVector<t>(x+right.x, y+right.y);
    }

    //向量相减
    mVector<t> minus(const mVector<t> &right)const
    {
        return mVector<t>(x-right.x, y-right.y);
    }

    //向量点乘
    T multipy(const mVector<t> &right)const
    {
        return x*right.x + y*right.y;
    }

    //判断两个向量是否平行 0--不平行 1--平行且方向相同 2--平行且方向相反
    int isParallel(const mVector<t> &right)const
    {
        if(x*right.y == y*right.x) //平行
        {
            if(x) //x!=0
            {
                if(right.x/x >= 0) return 1;
                else return -1;
            }
            else //x==0
            {
                if(y)
                {
                    if(right.y/y >= 0) return 1;
                    else return -1;
                }
                else {return 1;}
            }
        }

        return 0;
    }

    //判断两个向量是否相交
    bool isIntersect(const mVector<t> &right)const
    {
        return ! isParallel(right);
    }

    //判断两个向量是否垂直
    bool isPerpendicular(const mVector<t> &right)const
    {
        return !(this->multipy(right));
    }

    //获取向量的长度
    double getLength()const
    {
        return std::sqrt(double(x*x + y*y));
    }
};

//获取一组点中的下一个点
template <typename t="">
T getNextPoint(const std::vector<t> &rgn, size_t index)
{
    if(index == rgn.size()-1 ) return rgn.at(0);
    else return rgn.at(index+1);
}

//获取一组点中的上一个点
template <typename t="">
T getPrevPoint(const std::vector<t> &rgn, size_t index)
{
    if(0 == index) return rgn.at(rgn.size()-1);
    else return rgn.at(index-1);
}

//获取向量的垂直方向 -1--向上 1--向下 0--水平
template <typename t="">
int getVectorDirect(const mVector<t> &vec)
{
    if(vec.y > 0) return -1;
    else if(vec.y <0) return="" 1;="" else="" 0;="" }="" 判断点point是否在区域rgn内部="" 1--内部="" -1--边界="" 0--外部="" template="" <typename="" t="">
int isPointInRgn(const mVector<t> &point, const std::vector<mvector<t> > &rgn)
{
    int num1=0, num2=0;
    for(std::vector<mvector<t> >::size_type index=0; index != rgn.size(); index++ )
    {
        mVector<t> nextPoint = getNextPoint(rgn,index);

        if(rgn[index].x<point.x &&="" nextpoint.x<point.x)="" {continue;}="" 向右方向作射线="" else="" if(nextpoint.minus(point).isparallel(="" point.minus(rgn[index])="" )="=" 1)="" {="" return="" -1;="" 点在边界="" }="" if(point.y="=" rgn[index].y)="" 射线经过边界点="" mvector<t=""> prevVector = rgn[index].minus(getPrevPoint(rgn,index)), 
                       nextVector = getNextPoint(rgn,index).minus(rgn[index]);

            num2 += getVectorDirect(prevVector) + getVectorDirect(nextVector);

        }
        else if( (point.y > rgn[index].y && point.y < nextPoint.y)
            || (point.y > nextPoint.y && point.y < rgn[index].y) )
        {
            ++num1;
        }
        else {}//射线不经过边界线段
    }

    if((num1 + num2/2)%2) return 1;//奇数
    else return 0;
}

//判断区域B是否在区域A内部
template <typename t="">
bool isRgnInRgn(const std::vector<mvector<t> > &rgnB, const std::vector<mvector<t> > &rgnA)
{
    for(std::vector<mvector<t> >::size_type index = 0;
        index != rgnB.size(); index++)
    {
        if(! isPointInRgn(rgnB[index], rgnA) ) return false;
    }

    return true;
}

#endif //IS_POINT_IN_RGN
</mvector<t></mvector<t></mvector<t></typename></point.x></t></mvector<t></mvector<t></t></0)></t></typename></t></typename></t></typename></t></t></t></t></t></t></t></t></t></t></typename></vector></cmath></pre>

<p>使用方法演示</p>
<pre lang="cpp">
#include "isPointInRgn.h"
#include <iostream>
#include <fstream>

int main()
{
    double x1,y1;

    std::vector<mvector<double> > borderA,borderB;

    std::ifstream finA("in1.txt"), finB("in2.txt");

    while(finA>>x1>>y1)
    {
        borderA.push_back(mVector<double>(x1,y1) );
    }

    while(finB>>x1>>y1)
    {
        borderB.push_back(mVector<double>(x1,y1) );

    }

    std::cout<<isrgninrgn(borderb, bordera)<<std::endl;="" }="" <="" pre="">

<p>其中in1.txt 和 in2.txt 为输入文件，内容如下</p>
<pre lang="cmd">
0 0
0 1
0 2
0 3
1 3
2 3
2 2
3 2
4 2
4 3
5 3
5 2
5 1
5 0
</pre>
<pre lang="cmd">
1 1
1 2
2 3
2 1
</pre>

<p>如果发现代码bug请在本页留言</p>
<p>代码下载：<a href="http://bit.ly/isPointInRegion" target="_blank" rel="external">http://bit.ly/isPointInRegion</a><br>参考文章：<a href="http://www.cnblogs.com/xiaotie/archive/2010/11/08/1871424.html" target="_blank" rel="external">判断区域B是否在区域A内部的快速算法 - xiaotie - 博客园</a></p>
</isrgninrgn(borderb,></double></double></mvector<double></fstream></iostream></pre></div></article></div></section><footer><div class="paginator"><a href="/2011/04/09/svn-e8-bf-9e-e6-8e-a5-google-project-hosting/" class="prev">上一篇</a><a href="/2011/03/21/e9-a3-9e-e4-bf-a1api-e6-90-81-e6-b5-85-e2-80-a6/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://blog.tianqi.at">John Doe</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>