<!DOCTYPE html><html lang="zh-cn,en,default"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> HanDong's Blog</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/html5-audio-player/" target="_self" class="nav-list-link">MUSIC</a></li><li class="nav-list-item"><a href="https://twitter.com/likev" target="_blank" class="nav-list-link">TWITTER</a></li><li class="nav-list-item"><a href="https://github.com/likev" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2012/04/09/javascript-e4-b8-ad-e7-b1-bb-e7-9a-84-e5-ae-9e-e7-8e-b0-e6-96-b9-e5-bc-8f-e4-b9-8b-e4-b8-80/" class="post-title-link">Javascript 中类的实现方式之一</a></h2><div class="post-time">2012年4月9日</div><div class="post-content">世上本没有路，走的人多了……Javascript中本没有类，但可以用函数来实现类。
先来看简单的矩形类Rect的实现：
function Rect(w,h){    this.width = w;    this.height = h;}
var rect1 = new Rect(10,20);window.alert(‘rect1.width = ‘+rect1.width);上面实现了Rect</div><a href="/2012/04/09/javascript-e4-b8-ad-e7-b1-bb-e7-9a-84-e5-ae-9e-e7-8e-b0-e6-96-b9-e5-bc-8f-e4-b9-8b-e4-b8-80/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2012/04/01/e7-90-86-e8-a7-a3-e5-92-8c-e5-ba-94-e7-94-a8canvas-e5-8f-98-e6-8d-a2/" class="post-title-link">理解和应用canvas变换</a></h2><div class="post-time">2012年4月1日</div><div class="post-content">默认的canvas画布以左上角为原点，向右为x轴增长方向，向下为y轴增长方向。默认以像素为单位。
很多情况下使用默认绘图环境极为不便，默认坐标系与我们上学时经常用到的直角坐标系不太一致。
幸运的是我们可以利用为canvas提供的变换函数来进行坐标转换，比如将原点移动到画布中心，转换Y轴方向等。当调用一个变换函数时，接下来的绘图将自动变换。所以变换前应该先将当前环境保存下来，执行完绘图时恢复之前的环</div><a href="/2012/04/01/e7-90-86-e8-a7-a3-e5-92-8c-e5-ba-94-e7-94-a8canvas-e5-8f-98-e6-8d-a2/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2012/03/26/windows-e4-b8-ad-e7-9a-84-e5-a4-9a-e7-ba-bf-e7-a8-8b-e5-a4-84-e7-90-86/" class="post-title-link">windows中的多线程处理</a></h2><div class="post-time">2012年3月26日</div><div class="post-content">（一）建立新线程的函数1.Win32 API函数 CreateThread
HANDLE WINAPI CreateThread(
  __in_opt   LPSECURITY_ATTRIBUTES lpThreadAttributes,
  __in       SIZE_T dwStackSize,
  __in       LPTHREAD_START_ROUTINE lpStartAdd</div><a href="/2012/03/26/windows-e4-b8-ad-e7-9a-84-e5-a4-9a-e7-ba-bf-e7-a8-8b-e5-a4-84-e7-90-86/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2012/03/26/e5-af-b9window-e7-a8-8b-e5-ba-8f-e6-b6-88-e6-81-af-e5-be-aa-e7-8e-af-e7-9a-84-e7-90-86-e8-a7-a3/" class="post-title-link">对Window程序消息循环的理解</a></h2><div class="post-time">2012年3月26日</div><div class="post-content">
1.每个(创建窗口的)线程有一个消息队列，程序用下面的循环接收、转换消息，并将消息分发到合适的窗口处理程序：

    MSG msg = { };    while (GetMessage(&amp;msg, NULL, 0, 0))    {        TranslateMessage(&amp;msg);        DispatchMessage(&amp;msg);    }

</div><a href="/2012/03/26/e5-af-b9window-e7-a8-8b-e5-ba-8f-e6-b6-88-e6-81-af-e5-be-aa-e7-8e-af-e7-9a-84-e7-90-86-e8-a7-a3/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2012/03/25/cpp-string-1/" class="post-title-link">C++ 字符串字面值的使用</a></h2><div class="post-time">2012年3月25日</div><div class="post-content">以下语句将输出helloworld1234//code1	char *a = "helloworld";	std::cout&lt;&lt;a&lt;&lt;std::endl;
上面的a实际上是指向字符串字面值常量的起始地址，如果对a指向的字符进行赋值将会出现错误(比如 *(a+1) = ‘E’ 将出错)。实际上应该像下面这样定义指针a(上面那样定义也能编译通过，但不推荐):12//code2	</div><a href="/2012/03/25/cpp-string-1/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2012/03/13/boost-e4-b8-ad-e7-9a-84regex-e7-b1-bb-e5-ba-93-e5-b0-86-e9-83-a8-e5-88-86-e4-b8-ad-e6-96-87-e8-af-86-e5-88-ab-e4-b8-ba-e7-a9-ba-e7-99-bd-e5-ad-97-e7-ac-a6-e7-9a-84-e9-97-ae-e9-a2-98-e5-8e-9f-e5-9b-a0/" class="post-title-link">Boost中的Regex类库将部分中文识别为空白字符的问题原因及解决办法</a></h2><div class="post-time">2012年3月13日</div><div class="post-content">问题描述：使用字符类\s匹配一个字符串中的空白字符时，部分中文字符也将被识别为空白。
原因：查看Boost的Regex源代码可以发现，Regex使用cpp_regex_traits类(在文件 boost/regex/v4/cpp_regex_traits.hpp 中定义)来处理字符类

// class cpp_regex_traits_base:
// acts as a container f</div><a href="/2012/03/13/boost-e4-b8-ad-e7-9a-84regex-e7-b1-bb-e5-ba-93-e5-b0-86-e9-83-a8-e5-88-86-e4-b8-ad-e6-96-87-e8-af-86-e5-88-ab-e4-b8-ba-e7-a9-ba-e7-99-bd-e5-ad-97-e7-ac-a6-e7-9a-84-e9-97-ae-e9-a2-98-e5-8e-9f-e5-9b-a0/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2012/03/07/windows-e4-b8-8b-e7-bc-96-e8-af-91-e5-92-8c-e5-ae-89-e8-a3-85boost-e5-ba-93/" class="post-title-link">Windows下编译和安装Boost库的指定模块</a></h2><div class="post-time">2012年3月7日</div><div class="post-content">当然你可以使用www.boostpro.com提供的安装工具来安装，免去以下的步骤。但是那会安装许多不必要的文件，占用大量磁盘空间，有可能使你更迷惑。可参见这篇文章。
如果你想了解如何一步步编译安装Boost库，请接着往下读。
一、到官网(www.boost.org)下载最新版Boost并解压到任意目录先来看一下解压后的目录结构，以$BOOST_ROOT代表你Boost所在的目录

**$BOOS</div><a href="/2012/03/07/windows-e4-b8-8b-e7-bc-96-e8-af-91-e5-92-8c-e5-ae-89-e8-a3-85boost-e5-ba-93/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2012/03/07/c-e7-a8-8b-e5-ba-8f-e9-85-8d-e7-bd-ae-e7-b1-bb-e5-ba-93/" class="post-title-link">C++程序配置类库</a></h2><div class="post-time">2012年3月7日</div><div class="post-content">一、INI文件读取库除了使用Windows提供的API函数(见之前文章介绍)和Boost、QT、wxWidgets等类库提供的配置函数外，还可以使用下面的类库：
1.SimpleIni(code.jellycan.com/simpleini/)一个跨平台的类库，提供简单的API读写INI文件，支持ASCII, MBCS and Unicode文件格式。开源，使用MIT协议。使用方法：

    C</div><a href="/2012/03/07/c-e7-a8-8b-e5-ba-8f-e9-85-8d-e7-bd-ae-e7-b1-bb-e5-ba-93/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2012/02/21/e7-a7-91-e5-ad-a6-e5-ae-b6-e9-83-a8-e7-bd-b2-e6-bf-80-e5-85-89-e5-99-a8-e3-80-81gps-e6-8a-80-e6-9c-af-e6-9d-a5-e6-94-b9-e5-96-84-e9-99-8d-e9-9b-aa-e6-b5-8b-e9-87-8f/" class="post-title-link">科学家部署激光器、GPS技术来改善降雪测量</a></h2><div class="post-time">2012年2月21日</div><div class="post-content">通过配备专门的激光和GPS技术，国家大气研究中心（NCAR）的科学家们正在与同事一道解决一个关键的冬季天气奥秘：如何准确地测量地面上的降雪量。
运输船员，水资源管理者和其他那些重大安全决策者需要对于积雪深度如何在大范围内分布的精确测量。 但是当积雪量在单一区域或街道变化时，传统的测量设备，如雪压表或尺度杆往往不能够捕获  降雪总量。
[caption id=”attachment_1136” al</div><a href="/2012/02/21/e7-a7-91-e5-ad-a6-e5-ae-b6-e9-83-a8-e7-bd-b2-e6-bf-80-e5-85-89-e5-99-a8-e3-80-81gps-e6-8a-80-e6-9c-af-e6-9d-a5-e6-94-b9-e5-96-84-e9-99-8d-e9-9b-aa-e6-b5-8b-e9-87-8f/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2012/02/13/php-e4-bb-a3-e7-a0-81-e8-8e-b7-e5-8f-96-e5-bd-93-e5-89-8d-e7-b3-bb-e7-bb-9f-e7-9a-84cpu-e5-92-8c-e5-86-85-e5-ad-98-e7-9a-84-e7-a9-ba-e9-97-b2-e7-99-be-e5-88-86-e6-af-94/" class="post-title-link">PHP代码获取当前系统的CPU和内存的空闲百分比</a></h2><div class="post-time">2012年2月13日</div><div class="post-content">设想我们有一个php页面A比较耗资源，因此在每次执行页面A中的代码前需要检测一下系统目前CPU和内存的空闲百分比。我们可以利用下面几个函数来解决这个问题


//获取cpu的空闲百分比
function get_cpufree(){
    $cmd =  "top -n 1 -b -d 0.1 | grep 'Cpu'";//调用top命令和grep命令
    $lastline = exec</div><a href="/2012/02/13/php-e4-bb-a3-e7-a0-81-e8-8e-b7-e5-8f-96-e5-bd-93-e5-89-8d-e7-b3-bb-e7-bb-9f-e7-9a-84cpu-e5-92-8c-e5-86-85-e5-ad-98-e7-9a-84-e7-a9-ba-e9-97-b2-e7-99-be-e5-88-86-e6-af-94/" class="read-more">...阅读全文</a></article></li></ul></section><footer><div class="paginator"><a href="/page/2/" class="prev">上一页</a><a href="/page/4/" class="next">下一页</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://blog.tianqi.at">HanDong</a>, unless otherwise noted.</p></div></footer><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>